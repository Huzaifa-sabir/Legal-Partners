{"ast":null,"code":"import { collection, doc, addDoc, getDocs, getDoc, updateDoc, deleteDoc, query, where, orderBy, limit } from 'firebase/firestore';\nimport { ref, uploadBytes, getDownloadURL, deleteObject } from 'firebase/storage';\nimport { db, storage } from './firebase';\nimport toast from 'react-hot-toast';\nclass ClaimsService {\n  constructor() {\n    this.claimsCollection = collection(db, 'claims');\n    this.notificationsCollection = collection(db, 'notifications');\n  }\n\n  // Create new claim\n  async createClaim(claimData, files = []) {\n    try {\n      // Upload files if any\n      const uploadedFiles = [];\n      if (files.length > 0) {\n        for (const file of files) {\n          const fileName = `claims/${Date.now()}_${file.name}`;\n          const storageRef = ref(storage, fileName);\n          const snapshot = await uploadBytes(storageRef, file);\n          const downloadURL = await getDownloadURL(snapshot.ref);\n          uploadedFiles.push({\n            name: file.name,\n            url: downloadURL,\n            type: file.type,\n            size: file.size,\n            uploadedAt: new Date().toISOString()\n          });\n        }\n      }\n      const newClaim = {\n        ...claimData,\n        status: 'pending',\n        documents: uploadedFiles,\n        createdAt: new Date().toISOString(),\n        updatedAt: new Date().toISOString()\n      };\n      const docRef = await addDoc(this.claimsCollection, newClaim);\n\n      // Create notification for admin\n      await this.createNotification({\n        userId: 'admin',\n        type: 'new_claim',\n        title: 'New Claim Submitted',\n        message: `New claim submitted by ${claimData.clientName}`,\n        claimId: docRef.id,\n        read: false\n      });\n      toast.success('Claim submitted successfully');\n      return {\n        id: docRef.id,\n        ...newClaim\n      };\n    } catch (error) {\n      console.error('Error creating claim:', error);\n      toast.error('Failed to submit claim');\n      throw error;\n    }\n  }\n\n  // Get all claims (admin only)\n  async getAllClaims() {\n    try {\n      const q = query(this.claimsCollection, orderBy('createdAt', 'desc'));\n      const snapshot = await getDocs(q);\n      return snapshot.docs.map(doc => ({\n        id: doc.id,\n        ...doc.data()\n      }));\n    } catch (error) {\n      console.error('Error fetching claims:', error);\n      toast.error('Failed to fetch claims');\n      throw error;\n    }\n  }\n\n  // Get claims by user ID\n  async getClaimsByUserId(userId) {\n    try {\n      const q = query(this.claimsCollection, where('userId', '==', userId), orderBy('createdAt', 'desc'));\n      const snapshot = await getDocs(q);\n      return snapshot.docs.map(doc => ({\n        id: doc.id,\n        ...doc.data()\n      }));\n    } catch (error) {\n      console.error('Error fetching user claims:', error);\n      throw error;\n    }\n  }\n\n  // Get claim by ID\n  async getClaimById(claimId) {\n    try {\n      const claimDoc = await getDoc(doc(db, 'claims', claimId));\n      if (claimDoc.exists()) {\n        return {\n          id: claimDoc.id,\n          ...claimDoc.data()\n        };\n      }\n      return null;\n    } catch (error) {\n      console.error('Error fetching claim:', error);\n      throw error;\n    }\n  }\n\n  // Update claim status (admin only)\n  async updateClaimStatus(claimId, status, adminNotes = '') {\n    try {\n      const claim = await this.getClaimById(claimId);\n      if (!claim) {\n        throw new Error('Claim not found');\n      }\n      await updateDoc(doc(db, 'claims', claimId), {\n        status: status,\n        adminNotes: adminNotes,\n        updatedAt: new Date().toISOString(),\n        reviewedAt: new Date().toISOString()\n      });\n\n      // Create notification for user\n      await this.createNotification({\n        userId: claim.userId,\n        type: 'claim_status_update',\n        title: 'Claim Status Updated',\n        message: `Your claim has been ${status}`,\n        claimId: claimId,\n        read: false\n      });\n      toast.success(`Claim ${status} successfully`);\n      return true;\n    } catch (error) {\n      console.error('Error updating claim status:', error);\n      toast.error('Failed to update claim status');\n      throw error;\n    }\n  }\n\n  // Update claim\n  async updateClaim(claimId, updateData, newFiles = []) {\n    try {\n      const claim = await this.getClaimById(claimId);\n      if (!claim) {\n        throw new Error('Claim not found');\n      }\n\n      // Upload new files if any\n      const uploadedFiles = [...(claim.documents || [])];\n      if (newFiles.length > 0) {\n        for (const file of newFiles) {\n          const fileName = `claims/${Date.now()}_${file.name}`;\n          const storageRef = ref(storage, fileName);\n          const snapshot = await uploadBytes(storageRef, file);\n          const downloadURL = await getDownloadURL(snapshot.ref);\n          uploadedFiles.push({\n            name: file.name,\n            url: downloadURL,\n            type: file.type,\n            size: file.size,\n            uploadedAt: new Date().toISOString()\n          });\n        }\n      }\n      const updatedData = {\n        ...updateData,\n        documents: uploadedFiles,\n        updatedAt: new Date().toISOString()\n      };\n      await updateDoc(doc(db, 'claims', claimId), updatedData);\n      toast.success('Claim updated successfully');\n      return true;\n    } catch (error) {\n      console.error('Error updating claim:', error);\n      toast.error('Failed to update claim');\n      throw error;\n    }\n  }\n\n  // Delete claim\n  async deleteClaim(claimId) {\n    try {\n      const claim = await this.getClaimById(claimId);\n      if (!claim) {\n        throw new Error('Claim not found');\n      }\n\n      // Delete associated files from storage\n      if (claim.documents && claim.documents.length > 0) {\n        for (const doc of claim.documents) {\n          try {\n            const fileRef = ref(storage, doc.url);\n            await deleteObject(fileRef);\n          } catch (fileError) {\n            console.warn('Error deleting file:', fileError);\n          }\n        }\n      }\n      await deleteDoc(doc(db, 'claims', claimId));\n      toast.success('Claim deleted successfully');\n      return true;\n    } catch (error) {\n      console.error('Error deleting claim:', error);\n      toast.error('Failed to delete claim');\n      throw error;\n    }\n  }\n\n  // Get claims by status\n  async getClaimsByStatus(status) {\n    try {\n      const q = query(this.claimsCollection, where('status', '==', status), orderBy('createdAt', 'desc'));\n      const snapshot = await getDocs(q);\n      return snapshot.docs.map(doc => ({\n        id: doc.id,\n        ...doc.data()\n      }));\n    } catch (error) {\n      console.error('Error fetching claims by status:', error);\n      throw error;\n    }\n  }\n\n  // Search claims\n  async searchClaims(searchTerm) {\n    try {\n      const allClaims = await this.getAllClaims();\n      return allClaims.filter(claim => {\n        var _claim$clientName, _claim$claimType, _claim$description;\n        return ((_claim$clientName = claim.clientName) === null || _claim$clientName === void 0 ? void 0 : _claim$clientName.toLowerCase().includes(searchTerm.toLowerCase())) || ((_claim$claimType = claim.claimType) === null || _claim$claimType === void 0 ? void 0 : _claim$claimType.toLowerCase().includes(searchTerm.toLowerCase())) || ((_claim$description = claim.description) === null || _claim$description === void 0 ? void 0 : _claim$description.toLowerCase().includes(searchTerm.toLowerCase()));\n      });\n    } catch (error) {\n      console.error('Error searching claims:', error);\n      throw error;\n    }\n  }\n\n  // Get claim statistics\n  async getClaimStats() {\n    try {\n      const claims = await this.getAllClaims();\n      const stats = {\n        total: claims.length,\n        pending: claims.filter(claim => claim.status === 'pending').length,\n        approved: claims.filter(claim => claim.status === 'approved').length,\n        rejected: claims.filter(claim => claim.status === 'rejected').length,\n        inReview: claims.filter(claim => claim.status === 'in-review').length\n      };\n      return stats;\n    } catch (error) {\n      console.error('Error fetching claim stats:', error);\n      throw error;\n    }\n  }\n\n  // Create notification\n  async createNotification(notificationData) {\n    try {\n      const newNotification = {\n        ...notificationData,\n        createdAt: new Date().toISOString()\n      };\n      await addDoc(this.notificationsCollection, newNotification);\n      return true;\n    } catch (error) {\n      console.error('Error creating notification:', error);\n      throw error;\n    }\n  }\n\n  // Get notifications for user\n  async getNotificationsByUserId(userId) {\n    try {\n      const q = query(this.notificationsCollection, where('userId', '==', userId), orderBy('createdAt', 'desc'), limit(20));\n      const snapshot = await getDocs(q);\n      return snapshot.docs.map(doc => ({\n        id: doc.id,\n        ...doc.data()\n      }));\n    } catch (error) {\n      console.error('Error fetching notifications:', error);\n      throw error;\n    }\n  }\n\n  // Mark notification as read\n  async markNotificationAsRead(notificationId) {\n    try {\n      await updateDoc(doc(db, 'notifications', notificationId), {\n        read: true,\n        readAt: new Date().toISOString()\n      });\n      return true;\n    } catch (error) {\n      console.error('Error marking notification as read:', error);\n      throw error;\n    }\n  }\n\n  // Get recent claims\n  async getRecentClaims(limitCount = 5) {\n    try {\n      const q = query(this.claimsCollection, orderBy('createdAt', 'desc'), limit(limitCount));\n      const snapshot = await getDocs(q);\n      return snapshot.docs.map(doc => ({\n        id: doc.id,\n        ...doc.data()\n      }));\n    } catch (error) {\n      console.error('Error fetching recent claims:', error);\n      throw error;\n    }\n  }\n}\nexport default new ClaimsService();","map":{"version":3,"names":["collection","doc","addDoc","getDocs","getDoc","updateDoc","deleteDoc","query","where","orderBy","limit","ref","uploadBytes","getDownloadURL","deleteObject","db","storage","toast","ClaimsService","constructor","claimsCollection","notificationsCollection","createClaim","claimData","files","uploadedFiles","length","file","fileName","Date","now","name","storageRef","snapshot","downloadURL","push","url","type","size","uploadedAt","toISOString","newClaim","status","documents","createdAt","updatedAt","docRef","createNotification","userId","title","message","clientName","claimId","id","read","success","error","console","getAllClaims","q","docs","map","data","getClaimsByUserId","getClaimById","claimDoc","exists","updateClaimStatus","adminNotes","claim","Error","reviewedAt","updateClaim","updateData","newFiles","updatedData","deleteClaim","fileRef","fileError","warn","getClaimsByStatus","searchClaims","searchTerm","allClaims","filter","_claim$clientName","_claim$claimType","_claim$description","toLowerCase","includes","claimType","description","getClaimStats","claims","stats","total","pending","approved","rejected","inReview","notificationData","newNotification","getNotificationsByUserId","markNotificationAsRead","notificationId","readAt","getRecentClaims","limitCount"],"sources":["D:/Law/law-firm-app/src/services/claimsService.js"],"sourcesContent":["import { \r\n  collection, \r\n  doc, \r\n  addDoc, \r\n  getDocs, \r\n  getDoc, \r\n  updateDoc, \r\n  deleteDoc,\r\n  query,\r\n  where,\r\n  orderBy,\r\n  limit \r\n} from 'firebase/firestore';\r\nimport { \r\n  ref, \r\n  uploadBytes, \r\n  getDownloadURL, \r\n  deleteObject \r\n} from 'firebase/storage';\r\nimport { db, storage } from './firebase';\r\nimport toast from 'react-hot-toast';\r\n\r\nclass ClaimsService {\r\n  constructor() {\r\n    this.claimsCollection = collection(db, 'claims');\r\n    this.notificationsCollection = collection(db, 'notifications');\r\n  }\r\n\r\n  // Create new claim\r\n  async createClaim(claimData, files = []) {\r\n    try {\r\n      // Upload files if any\r\n      const uploadedFiles = [];\r\n      if (files.length > 0) {\r\n        for (const file of files) {\r\n          const fileName = `claims/${Date.now()}_${file.name}`;\r\n          const storageRef = ref(storage, fileName);\r\n          const snapshot = await uploadBytes(storageRef, file);\r\n          const downloadURL = await getDownloadURL(snapshot.ref);\r\n          \r\n          uploadedFiles.push({\r\n            name: file.name,\r\n            url: downloadURL,\r\n            type: file.type,\r\n            size: file.size,\r\n            uploadedAt: new Date().toISOString()\r\n          });\r\n        }\r\n      }\r\n\r\n      const newClaim = {\r\n        ...claimData,\r\n        status: 'pending',\r\n        documents: uploadedFiles,\r\n        createdAt: new Date().toISOString(),\r\n        updatedAt: new Date().toISOString()\r\n      };\r\n\r\n      const docRef = await addDoc(this.claimsCollection, newClaim);\r\n      \r\n      // Create notification for admin\r\n      await this.createNotification({\r\n        userId: 'admin',\r\n        type: 'new_claim',\r\n        title: 'New Claim Submitted',\r\n        message: `New claim submitted by ${claimData.clientName}`,\r\n        claimId: docRef.id,\r\n        read: false\r\n      });\r\n\r\n      toast.success('Claim submitted successfully');\r\n      \r\n      return {\r\n        id: docRef.id,\r\n        ...newClaim\r\n      };\r\n    } catch (error) {\r\n      console.error('Error creating claim:', error);\r\n      toast.error('Failed to submit claim');\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  // Get all claims (admin only)\r\n  async getAllClaims() {\r\n    try {\r\n      const q = query(this.claimsCollection, orderBy('createdAt', 'desc'));\r\n      const snapshot = await getDocs(q);\r\n      \r\n      return snapshot.docs.map(doc => ({\r\n        id: doc.id,\r\n        ...doc.data()\r\n      }));\r\n    } catch (error) {\r\n      console.error('Error fetching claims:', error);\r\n      toast.error('Failed to fetch claims');\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  // Get claims by user ID\r\n  async getClaimsByUserId(userId) {\r\n    try {\r\n      const q = query(\r\n        this.claimsCollection,\r\n        where('userId', '==', userId),\r\n        orderBy('createdAt', 'desc')\r\n      );\r\n      const snapshot = await getDocs(q);\r\n      \r\n      return snapshot.docs.map(doc => ({\r\n        id: doc.id,\r\n        ...doc.data()\r\n      }));\r\n    } catch (error) {\r\n      console.error('Error fetching user claims:', error);\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  // Get claim by ID\r\n  async getClaimById(claimId) {\r\n    try {\r\n      const claimDoc = await getDoc(doc(db, 'claims', claimId));\r\n      \r\n      if (claimDoc.exists()) {\r\n        return {\r\n          id: claimDoc.id,\r\n          ...claimDoc.data()\r\n        };\r\n      }\r\n      return null;\r\n    } catch (error) {\r\n      console.error('Error fetching claim:', error);\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  // Update claim status (admin only)\r\n  async updateClaimStatus(claimId, status, adminNotes = '') {\r\n    try {\r\n      const claim = await this.getClaimById(claimId);\r\n      if (!claim) {\r\n        throw new Error('Claim not found');\r\n      }\r\n\r\n      await updateDoc(doc(db, 'claims', claimId), {\r\n        status: status,\r\n        adminNotes: adminNotes,\r\n        updatedAt: new Date().toISOString(),\r\n        reviewedAt: new Date().toISOString()\r\n      });\r\n\r\n      // Create notification for user\r\n      await this.createNotification({\r\n        userId: claim.userId,\r\n        type: 'claim_status_update',\r\n        title: 'Claim Status Updated',\r\n        message: `Your claim has been ${status}`,\r\n        claimId: claimId,\r\n        read: false\r\n      });\r\n\r\n      toast.success(`Claim ${status} successfully`);\r\n      return true;\r\n    } catch (error) {\r\n      console.error('Error updating claim status:', error);\r\n      toast.error('Failed to update claim status');\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  // Update claim\r\n  async updateClaim(claimId, updateData, newFiles = []) {\r\n    try {\r\n      const claim = await this.getClaimById(claimId);\r\n      if (!claim) {\r\n        throw new Error('Claim not found');\r\n      }\r\n\r\n      // Upload new files if any\r\n      const uploadedFiles = [...(claim.documents || [])];\r\n      if (newFiles.length > 0) {\r\n        for (const file of newFiles) {\r\n          const fileName = `claims/${Date.now()}_${file.name}`;\r\n          const storageRef = ref(storage, fileName);\r\n          const snapshot = await uploadBytes(storageRef, file);\r\n          const downloadURL = await getDownloadURL(snapshot.ref);\r\n          \r\n          uploadedFiles.push({\r\n            name: file.name,\r\n            url: downloadURL,\r\n            type: file.type,\r\n            size: file.size,\r\n            uploadedAt: new Date().toISOString()\r\n          });\r\n        }\r\n      }\r\n\r\n      const updatedData = {\r\n        ...updateData,\r\n        documents: uploadedFiles,\r\n        updatedAt: new Date().toISOString()\r\n      };\r\n\r\n      await updateDoc(doc(db, 'claims', claimId), updatedData);\r\n      toast.success('Claim updated successfully');\r\n      \r\n      return true;\r\n    } catch (error) {\r\n      console.error('Error updating claim:', error);\r\n      toast.error('Failed to update claim');\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  // Delete claim\r\n  async deleteClaim(claimId) {\r\n    try {\r\n      const claim = await this.getClaimById(claimId);\r\n      if (!claim) {\r\n        throw new Error('Claim not found');\r\n      }\r\n\r\n      // Delete associated files from storage\r\n      if (claim.documents && claim.documents.length > 0) {\r\n        for (const doc of claim.documents) {\r\n          try {\r\n            const fileRef = ref(storage, doc.url);\r\n            await deleteObject(fileRef);\r\n          } catch (fileError) {\r\n            console.warn('Error deleting file:', fileError);\r\n          }\r\n        }\r\n      }\r\n\r\n      await deleteDoc(doc(db, 'claims', claimId));\r\n      toast.success('Claim deleted successfully');\r\n      \r\n      return true;\r\n    } catch (error) {\r\n      console.error('Error deleting claim:', error);\r\n      toast.error('Failed to delete claim');\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  // Get claims by status\r\n  async getClaimsByStatus(status) {\r\n    try {\r\n      const q = query(\r\n        this.claimsCollection,\r\n        where('status', '==', status),\r\n        orderBy('createdAt', 'desc')\r\n      );\r\n      const snapshot = await getDocs(q);\r\n      \r\n      return snapshot.docs.map(doc => ({\r\n        id: doc.id,\r\n        ...doc.data()\r\n      }));\r\n    } catch (error) {\r\n      console.error('Error fetching claims by status:', error);\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  // Search claims\r\n  async searchClaims(searchTerm) {\r\n    try {\r\n      const allClaims = await this.getAllClaims();\r\n      \r\n      return allClaims.filter(claim => \r\n        claim.clientName?.toLowerCase().includes(searchTerm.toLowerCase()) ||\r\n        claim.claimType?.toLowerCase().includes(searchTerm.toLowerCase()) ||\r\n        claim.description?.toLowerCase().includes(searchTerm.toLowerCase())\r\n      );\r\n    } catch (error) {\r\n      console.error('Error searching claims:', error);\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  // Get claim statistics\r\n  async getClaimStats() {\r\n    try {\r\n      const claims = await this.getAllClaims();\r\n      \r\n      const stats = {\r\n        total: claims.length,\r\n        pending: claims.filter(claim => claim.status === 'pending').length,\r\n        approved: claims.filter(claim => claim.status === 'approved').length,\r\n        rejected: claims.filter(claim => claim.status === 'rejected').length,\r\n        inReview: claims.filter(claim => claim.status === 'in-review').length\r\n      };\r\n      \r\n      return stats;\r\n    } catch (error) {\r\n      console.error('Error fetching claim stats:', error);\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  // Create notification\r\n  async createNotification(notificationData) {\r\n    try {\r\n      const newNotification = {\r\n        ...notificationData,\r\n        createdAt: new Date().toISOString()\r\n      };\r\n\r\n      await addDoc(this.notificationsCollection, newNotification);\r\n      return true;\r\n    } catch (error) {\r\n      console.error('Error creating notification:', error);\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  // Get notifications for user\r\n  async getNotificationsByUserId(userId) {\r\n    try {\r\n      const q = query(\r\n        this.notificationsCollection,\r\n        where('userId', '==', userId),\r\n        orderBy('createdAt', 'desc'),\r\n        limit(20)\r\n      );\r\n      const snapshot = await getDocs(q);\r\n      \r\n      return snapshot.docs.map(doc => ({\r\n        id: doc.id,\r\n        ...doc.data()\r\n      }));\r\n    } catch (error) {\r\n      console.error('Error fetching notifications:', error);\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  // Mark notification as read\r\n  async markNotificationAsRead(notificationId) {\r\n    try {\r\n      await updateDoc(doc(db, 'notifications', notificationId), {\r\n        read: true,\r\n        readAt: new Date().toISOString()\r\n      });\r\n      return true;\r\n    } catch (error) {\r\n      console.error('Error marking notification as read:', error);\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  // Get recent claims\r\n  async getRecentClaims(limitCount = 5) {\r\n    try {\r\n      const q = query(\r\n        this.claimsCollection,\r\n        orderBy('createdAt', 'desc'),\r\n        limit(limitCount)\r\n      );\r\n      const snapshot = await getDocs(q);\r\n      \r\n      return snapshot.docs.map(doc => ({\r\n        id: doc.id,\r\n        ...doc.data()\r\n      }));\r\n    } catch (error) {\r\n      console.error('Error fetching recent claims:', error);\r\n      throw error;\r\n    }\r\n  }\r\n}\r\n\r\nexport default new ClaimsService();"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}