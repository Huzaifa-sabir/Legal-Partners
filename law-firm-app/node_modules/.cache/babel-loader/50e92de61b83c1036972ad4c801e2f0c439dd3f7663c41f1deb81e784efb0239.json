{"ast":null,"code":"import { db } from './localStorage';\nimport toast from 'react-hot-toast';\nclass ClaimsService {\n  constructor() {\n    this.claimsCollection = 'claims';\n    this.notificationsCollection = 'notifications';\n  }\n\n  // Create new claim\n  async createClaim(claimData, files = []) {\n    try {\n      // Upload files if any\n      const uploadedFiles = [];\n      if (files.length > 0) {\n        for (const file of files) {\n          try {\n            const uploadedFile = await db.uploadFile(file);\n            uploadedFiles.push(uploadedFile);\n          } catch (fileError) {\n            console.warn('Error uploading file:', fileError);\n            toast.error(`Failed to upload ${file.name}`);\n          }\n        }\n      }\n      const newClaim = {\n        ...claimData,\n        status: 'pending',\n        documents: uploadedFiles\n      };\n      const claim = db.create(this.claimsCollection, newClaim);\n\n      // Create notification for admin\n      await this.createNotification({\n        userId: 'admin',\n        type: 'new_claim',\n        title: 'New Claim Submitted',\n        message: `New claim submitted by ${claimData.clientName}`,\n        claimId: claim.id,\n        read: false\n      });\n      toast.success('Claim submitted successfully');\n      return claim;\n    } catch (error) {\n      console.error('Error creating claim:', error);\n      toast.error('Failed to submit claim');\n      throw error;\n    }\n  }\n\n  // Get all claims (admin only)\n  async getAllClaims() {\n    try {\n      const claims = db.getAll(this.claimsCollection);\n      return claims.sort((a, b) => new Date(b.createdAt) - new Date(a.createdAt));\n    } catch (error) {\n      console.error('Error fetching claims:', error);\n      toast.error('Failed to fetch claims');\n      throw error;\n    }\n  }\n\n  // Get claims by user ID\n  async getClaimsByUserId(userId) {\n    try {\n      const claims = db.where(this.claimsCollection, 'userId', '==', userId);\n      return claims.sort((a, b) => new Date(b.createdAt) - new Date(a.createdAt));\n    } catch (error) {\n      console.error('Error fetching user claims:', error);\n      throw error;\n    }\n  }\n\n  // Get claim by ID\n  async getClaimById(claimId) {\n    try {\n      const claim = db.getById(this.claimsCollection, claimId);\n      return claim;\n    } catch (error) {\n      console.error('Error fetching claim:', error);\n      throw error;\n    }\n  }\n\n  // Update claim status (admin only)\n  async updateClaimStatus(claimId, status, adminNotes = '') {\n    try {\n      const claim = await this.getClaimById(claimId);\n      if (!claim) {\n        throw new Error('Claim not found');\n      }\n      const updatedClaim = db.update(this.claimsCollection, claimId, {\n        status: status,\n        adminNotes: adminNotes,\n        reviewedAt: new Date().toISOString()\n      });\n      if (updatedClaim) {\n        // Create notification for user\n        await this.createNotification({\n          userId: claim.userId,\n          type: 'claim_status_update',\n          title: 'Claim Status Updated',\n          message: `Your claim has been ${status}`,\n          claimId: claimId,\n          read: false\n        });\n        toast.success(`Claim ${status} successfully`);\n        return true;\n      }\n      throw new Error('Failed to update claim');\n    } catch (error) {\n      console.error('Error updating claim status:', error);\n      toast.error('Failed to update claim status');\n      throw error;\n    }\n  }\n\n  // Update claim\n  async updateClaim(claimId, updateData, newFiles = []) {\n    try {\n      const claim = await this.getClaimById(claimId);\n      if (!claim) {\n        throw new Error('Claim not found');\n      }\n\n      // Upload new files if any\n      const uploadedFiles = [...(claim.documents || [])];\n      if (newFiles.length > 0) {\n        for (const file of newFiles) {\n          try {\n            const uploadedFile = await db.uploadFile(file);\n            uploadedFiles.push(uploadedFile);\n          } catch (fileError) {\n            console.warn('Error uploading file:', fileError);\n            toast.error(`Failed to upload ${file.name}`);\n          }\n        }\n      }\n      const updatedData = {\n        ...updateData,\n        documents: uploadedFiles\n      };\n      const updatedClaim = db.update(this.claimsCollection, claimId, updatedData);\n      if (updatedClaim) {\n        toast.success('Claim updated successfully');\n        return true;\n      }\n      throw new Error('Failed to update claim');\n    } catch (error) {\n      console.error('Error updating claim:', error);\n      toast.error('Failed to update claim');\n      throw error;\n    }\n  }\n\n  // Delete claim\n  async deleteClaim(claimId) {\n    try {\n      const claim = await this.getClaimById(claimId);\n      if (!claim) {\n        throw new Error('Claim not found');\n      }\n\n      // In a real implementation, you would delete files from storage here\n      // For localStorage demo, we'll just remove the claim\n\n      const success = db.delete(this.claimsCollection, claimId);\n      if (success) {\n        toast.success('Claim deleted successfully');\n        return true;\n      }\n      throw new Error('Failed to delete claim');\n    } catch (error) {\n      console.error('Error deleting claim:', error);\n      toast.error('Failed to delete claim');\n      throw error;\n    }\n  }\n\n  // Get claims by status\n  async getClaimsByStatus(status) {\n    try {\n      const claims = db.where(this.claimsCollection, 'status', '==', status);\n      return claims.sort((a, b) => new Date(b.createdAt) - new Date(a.createdAt));\n    } catch (error) {\n      console.error('Error fetching claims by status:', error);\n      throw error;\n    }\n  }\n\n  // Search claims\n  async searchClaims(searchTerm) {\n    try {\n      const allClaims = await this.getAllClaims();\n      return allClaims.filter(claim => {\n        var _claim$clientName, _claim$claimType, _claim$description;\n        return ((_claim$clientName = claim.clientName) === null || _claim$clientName === void 0 ? void 0 : _claim$clientName.toLowerCase().includes(searchTerm.toLowerCase())) || ((_claim$claimType = claim.claimType) === null || _claim$claimType === void 0 ? void 0 : _claim$claimType.toLowerCase().includes(searchTerm.toLowerCase())) || ((_claim$description = claim.description) === null || _claim$description === void 0 ? void 0 : _claim$description.toLowerCase().includes(searchTerm.toLowerCase()));\n      });\n    } catch (error) {\n      console.error('Error searching claims:', error);\n      throw error;\n    }\n  }\n\n  // Get claim statistics\n  async getClaimStats() {\n    try {\n      const claims = await this.getAllClaims();\n      const stats = {\n        total: claims.length,\n        pending: claims.filter(claim => claim.status === 'pending').length,\n        approved: claims.filter(claim => claim.status === 'approved').length,\n        rejected: claims.filter(claim => claim.status === 'rejected').length,\n        inReview: claims.filter(claim => claim.status === 'in-review').length\n      };\n      return stats;\n    } catch (error) {\n      console.error('Error fetching claim stats:', error);\n      throw error;\n    }\n  }\n\n  // Create notification\n  async createNotification(notificationData) {\n    try {\n      const notification = db.create(this.notificationsCollection, notificationData);\n      return notification;\n    } catch (error) {\n      console.error('Error creating notification:', error);\n      throw error;\n    }\n  }\n\n  // Get notifications for user\n  async getNotificationsByUserId(userId) {\n    try {\n      const notifications = db.where(this.notificationsCollection, 'userId', '==', userId);\n      // Also get admin notifications if user is admin\n      if (userId === 'admin') {\n        const adminNotifications = db.where(this.notificationsCollection, 'userId', '==', 'admin');\n        notifications.push(...adminNotifications);\n      }\n      return notifications.sort((a, b) => new Date(b.createdAt) - new Date(a.createdAt)).slice(0, 20); // Limit to 20 notifications\n    } catch (error) {\n      console.error('Error fetching notifications:', error);\n      throw error;\n    }\n  }\n\n  // Mark notification as read\n  async markNotificationAsRead(notificationId) {\n    try {\n      const updatedNotification = db.update(this.notificationsCollection, notificationId, {\n        read: true,\n        readAt: new Date().toISOString()\n      });\n      return !!updatedNotification;\n    } catch (error) {\n      console.error('Error marking notification as read:', error);\n      throw error;\n    }\n  }\n\n  // Get recent claims\n  async getRecentClaims(limitCount = 5) {\n    try {\n      const claims = db.getAll(this.claimsCollection);\n      const sortedClaims = claims.sort((a, b) => new Date(b.createdAt) - new Date(a.createdAt));\n      return sortedClaims.slice(0, limitCount);\n    } catch (error) {\n      console.error('Error fetching recent claims:', error);\n      throw error;\n    }\n  }\n\n  // Get claims by date range\n  async getClaimsByDateRange(startDate, endDate) {\n    try {\n      const claims = db.getAll(this.claimsCollection);\n      return claims.filter(claim => {\n        const claimDate = new Date(claim.createdAt);\n        return claimDate >= new Date(startDate) && claimDate <= new Date(endDate);\n      });\n    } catch (error) {\n      console.error('Error fetching claims by date range:', error);\n      throw error;\n    }\n  }\n\n  // Get claims by priority\n  async getClaimsByPriority(priority) {\n    try {\n      const claims = db.where(this.claimsCollection, 'priority', '==', priority);\n      return claims.sort((a, b) => new Date(b.createdAt) - new Date(a.createdAt));\n    } catch (error) {\n      console.error('Error fetching claims by priority:', error);\n      throw error;\n    }\n  }\n}\nexport default new ClaimsService();","map":{"version":3,"names":["db","toast","ClaimsService","constructor","claimsCollection","notificationsCollection","createClaim","claimData","files","uploadedFiles","length","file","uploadedFile","uploadFile","push","fileError","console","warn","error","name","newClaim","status","documents","claim","create","createNotification","userId","type","title","message","clientName","claimId","id","read","success","getAllClaims","claims","getAll","sort","a","b","Date","createdAt","getClaimsByUserId","where","getClaimById","getById","updateClaimStatus","adminNotes","Error","updatedClaim","update","reviewedAt","toISOString","updateClaim","updateData","newFiles","updatedData","deleteClaim","delete","getClaimsByStatus","searchClaims","searchTerm","allClaims","filter","_claim$clientName","_claim$claimType","_claim$description","toLowerCase","includes","claimType","description","getClaimStats","stats","total","pending","approved","rejected","inReview","notificationData","notification","getNotificationsByUserId","notifications","adminNotifications","slice","markNotificationAsRead","notificationId","updatedNotification","readAt","getRecentClaims","limitCount","sortedClaims","getClaimsByDateRange","startDate","endDate","claimDate","getClaimsByPriority","priority"],"sources":["D:/Law/law-firm-app/src/services/claimsService.js"],"sourcesContent":["import { db } from './localStorage';\r\nimport toast from 'react-hot-toast';\r\n\r\nclass ClaimsService {\r\n  constructor() {\r\n    this.claimsCollection = 'claims';\r\n    this.notificationsCollection = 'notifications';\r\n  }\r\n\r\n  // Create new claim\r\n  async createClaim(claimData, files = []) {\r\n    try {\r\n      // Upload files if any\r\n      const uploadedFiles = [];\r\n      if (files.length > 0) {\r\n        for (const file of files) {\r\n          try {\r\n            const uploadedFile = await db.uploadFile(file);\r\n            uploadedFiles.push(uploadedFile);\r\n          } catch (fileError) {\r\n            console.warn('Error uploading file:', fileError);\r\n            toast.error(`Failed to upload ${file.name}`);\r\n          }\r\n        }\r\n      }\r\n\r\n      const newClaim = {\r\n        ...claimData,\r\n        status: 'pending',\r\n        documents: uploadedFiles\r\n      };\r\n\r\n      const claim = db.create(this.claimsCollection, newClaim);\r\n      \r\n      // Create notification for admin\r\n      await this.createNotification({\r\n        userId: 'admin',\r\n        type: 'new_claim',\r\n        title: 'New Claim Submitted',\r\n        message: `New claim submitted by ${claimData.clientName}`,\r\n        claimId: claim.id,\r\n        read: false\r\n      });\r\n\r\n      toast.success('Claim submitted successfully');\r\n      \r\n      return claim;\r\n    } catch (error) {\r\n      console.error('Error creating claim:', error);\r\n      toast.error('Failed to submit claim');\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  // Get all claims (admin only)\r\n  async getAllClaims() {\r\n    try {\r\n      const claims = db.getAll(this.claimsCollection);\r\n      return claims.sort((a, b) => new Date(b.createdAt) - new Date(a.createdAt));\r\n    } catch (error) {\r\n      console.error('Error fetching claims:', error);\r\n      toast.error('Failed to fetch claims');\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  // Get claims by user ID\r\n  async getClaimsByUserId(userId) {\r\n    try {\r\n      const claims = db.where(this.claimsCollection, 'userId', '==', userId);\r\n      return claims.sort((a, b) => new Date(b.createdAt) - new Date(a.createdAt));\r\n    } catch (error) {\r\n      console.error('Error fetching user claims:', error);\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  // Get claim by ID\r\n  async getClaimById(claimId) {\r\n    try {\r\n      const claim = db.getById(this.claimsCollection, claimId);\r\n      return claim;\r\n    } catch (error) {\r\n      console.error('Error fetching claim:', error);\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  // Update claim status (admin only)\r\n  async updateClaimStatus(claimId, status, adminNotes = '') {\r\n    try {\r\n      const claim = await this.getClaimById(claimId);\r\n      if (!claim) {\r\n        throw new Error('Claim not found');\r\n      }\r\n\r\n      const updatedClaim = db.update(this.claimsCollection, claimId, {\r\n        status: status,\r\n        adminNotes: adminNotes,\r\n        reviewedAt: new Date().toISOString()\r\n      });\r\n\r\n      if (updatedClaim) {\r\n        // Create notification for user\r\n        await this.createNotification({\r\n          userId: claim.userId,\r\n          type: 'claim_status_update',\r\n          title: 'Claim Status Updated',\r\n          message: `Your claim has been ${status}`,\r\n          claimId: claimId,\r\n          read: false\r\n        });\r\n\r\n        toast.success(`Claim ${status} successfully`);\r\n        return true;\r\n      }\r\n      throw new Error('Failed to update claim');\r\n    } catch (error) {\r\n      console.error('Error updating claim status:', error);\r\n      toast.error('Failed to update claim status');\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  // Update claim\r\n  async updateClaim(claimId, updateData, newFiles = []) {\r\n    try {\r\n      const claim = await this.getClaimById(claimId);\r\n      if (!claim) {\r\n        throw new Error('Claim not found');\r\n      }\r\n\r\n      // Upload new files if any\r\n      const uploadedFiles = [...(claim.documents || [])];\r\n      if (newFiles.length > 0) {\r\n        for (const file of newFiles) {\r\n          try {\r\n            const uploadedFile = await db.uploadFile(file);\r\n            uploadedFiles.push(uploadedFile);\r\n          } catch (fileError) {\r\n            console.warn('Error uploading file:', fileError);\r\n            toast.error(`Failed to upload ${file.name}`);\r\n          }\r\n        }\r\n      }\r\n\r\n      const updatedData = {\r\n        ...updateData,\r\n        documents: uploadedFiles\r\n      };\r\n\r\n      const updatedClaim = db.update(this.claimsCollection, claimId, updatedData);\r\n      \r\n      if (updatedClaim) {\r\n        toast.success('Claim updated successfully');\r\n        return true;\r\n      }\r\n      throw new Error('Failed to update claim');\r\n    } catch (error) {\r\n      console.error('Error updating claim:', error);\r\n      toast.error('Failed to update claim');\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  // Delete claim\r\n  async deleteClaim(claimId) {\r\n    try {\r\n      const claim = await this.getClaimById(claimId);\r\n      if (!claim) {\r\n        throw new Error('Claim not found');\r\n      }\r\n\r\n      // In a real implementation, you would delete files from storage here\r\n      // For localStorage demo, we'll just remove the claim\r\n\r\n      const success = db.delete(this.claimsCollection, claimId);\r\n      if (success) {\r\n        toast.success('Claim deleted successfully');\r\n        return true;\r\n      }\r\n      throw new Error('Failed to delete claim');\r\n    } catch (error) {\r\n      console.error('Error deleting claim:', error);\r\n      toast.error('Failed to delete claim');\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  // Get claims by status\r\n  async getClaimsByStatus(status) {\r\n    try {\r\n      const claims = db.where(this.claimsCollection, 'status', '==', status);\r\n      return claims.sort((a, b) => new Date(b.createdAt) - new Date(a.createdAt));\r\n    } catch (error) {\r\n      console.error('Error fetching claims by status:', error);\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  // Search claims\r\n  async searchClaims(searchTerm) {\r\n    try {\r\n      const allClaims = await this.getAllClaims();\r\n      \r\n      return allClaims.filter(claim => \r\n        claim.clientName?.toLowerCase().includes(searchTerm.toLowerCase()) ||\r\n        claim.claimType?.toLowerCase().includes(searchTerm.toLowerCase()) ||\r\n        claim.description?.toLowerCase().includes(searchTerm.toLowerCase())\r\n      );\r\n    } catch (error) {\r\n      console.error('Error searching claims:', error);\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  // Get claim statistics\r\n  async getClaimStats() {\r\n    try {\r\n      const claims = await this.getAllClaims();\r\n      \r\n      const stats = {\r\n        total: claims.length,\r\n        pending: claims.filter(claim => claim.status === 'pending').length,\r\n        approved: claims.filter(claim => claim.status === 'approved').length,\r\n        rejected: claims.filter(claim => claim.status === 'rejected').length,\r\n        inReview: claims.filter(claim => claim.status === 'in-review').length\r\n      };\r\n      \r\n      return stats;\r\n    } catch (error) {\r\n      console.error('Error fetching claim stats:', error);\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  // Create notification\r\n  async createNotification(notificationData) {\r\n    try {\r\n      const notification = db.create(this.notificationsCollection, notificationData);\r\n      return notification;\r\n    } catch (error) {\r\n      console.error('Error creating notification:', error);\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  // Get notifications for user\r\n  async getNotificationsByUserId(userId) {\r\n    try {\r\n      const notifications = db.where(this.notificationsCollection, 'userId', '==', userId);\r\n      // Also get admin notifications if user is admin\r\n      if (userId === 'admin') {\r\n        const adminNotifications = db.where(this.notificationsCollection, 'userId', '==', 'admin');\r\n        notifications.push(...adminNotifications);\r\n      }\r\n      \r\n      return notifications\r\n        .sort((a, b) => new Date(b.createdAt) - new Date(a.createdAt))\r\n        .slice(0, 20); // Limit to 20 notifications\r\n    } catch (error) {\r\n      console.error('Error fetching notifications:', error);\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  // Mark notification as read\r\n  async markNotificationAsRead(notificationId) {\r\n    try {\r\n      const updatedNotification = db.update(this.notificationsCollection, notificationId, {\r\n        read: true,\r\n        readAt: new Date().toISOString()\r\n      });\r\n      return !!updatedNotification;\r\n    } catch (error) {\r\n      console.error('Error marking notification as read:', error);\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  // Get recent claims\r\n  async getRecentClaims(limitCount = 5) {\r\n    try {\r\n      const claims = db.getAll(this.claimsCollection);\r\n      const sortedClaims = claims.sort((a, b) => new Date(b.createdAt) - new Date(a.createdAt));\r\n      return sortedClaims.slice(0, limitCount);\r\n    } catch (error) {\r\n      console.error('Error fetching recent claims:', error);\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  // Get claims by date range\r\n  async getClaimsByDateRange(startDate, endDate) {\r\n    try {\r\n      const claims = db.getAll(this.claimsCollection);\r\n      return claims.filter(claim => {\r\n        const claimDate = new Date(claim.createdAt);\r\n        return claimDate >= new Date(startDate) && claimDate <= new Date(endDate);\r\n      });\r\n    } catch (error) {\r\n      console.error('Error fetching claims by date range:', error);\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  // Get claims by priority\r\n  async getClaimsByPriority(priority) {\r\n    try {\r\n      const claims = db.where(this.claimsCollection, 'priority', '==', priority);\r\n      return claims.sort((a, b) => new Date(b.createdAt) - new Date(a.createdAt));\r\n    } catch (error) {\r\n      console.error('Error fetching claims by priority:', error);\r\n      throw error;\r\n    }\r\n  }\r\n}\r\n\r\nexport default new ClaimsService();"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}